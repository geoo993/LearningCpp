/*
 * ring.h
 *
 *  Created on: 5 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef RING_H_
#define RING_H_

#include <iostream>
using namespace std;

template<typename T>
class ring {
private:
	int initial_size;
	T *m_values;

public:

	class iterator;

public:

	ring();
	ring(int initial_size) : initial_size(initial_size), m_values(NULL){
		m_values = new T[initial_size];
	}

	~ring(){
		delete [] m_values;
	}

	//containers
public:

	int size() const{
		return initial_size;
	}

	void clear(){

	}

	void swap(int x);   // clear x reallocating

//sequences
public:

	 T & operator[](int index) const
	 T & operator[](int index) const; // & the Bad
	 T & front() {
	 return operator[](0);
	 }
	 const T & front() const {
	 return operator[](0);
	 }
	 T & back() {
	 return operator[](size() - 1);
	 }
	 const T & back() const {
	 return operator[](size() - 1);
	 }
	 void add(const T & x);
	 void pop();



};


template<typename T>
class ring<T>::iterator {
public:
	void print(){
		cout << "Hello from Ring iterator... Type Id: " << typeid(T).name() << endl;
	}

};


#endif /* RING_H_ */
