/*
 * ring.h
 *
 *  Created on: 5 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef RING_H_
#define RING_H_

#include <iostream>
#include <cstdlib>
using namespace std;

template<class el>
class AeDynArray {
public:
	AeDynArray(); // constructor
	AeDynArray(const AeDynArray &a); // copy constructor
	~AeDynArray(); // distructor
	AeDynArray& operator =(const AeDynArray &a); // assignment operator

	el& operator [](unsigned int index); // get array item
	void Add(const el &item); // Add item to the end of array

	unsigned int GetSize(); // get size of array (elements)
	void SetSize(unsigned int newsize); // set size of array (elements)
	void Clear(); // clear array
	void Delete(unsigned int pos); // delete array item
	void* getptr(); // get void* pointer to array data

	enum exception {
		MEMFAIL
	}; // exception enum

};

template<typename T>
class ring {
private:

	unsigned int m_pos;//position in the array
	unsigned int m_size; //size of the array (elements)
	unsigned int m_realsize; // actual size of allocated memory
	const static int dyn_array_step = 128; // initial size of array memory (elements)
	const static int dyn_array_mult = 2; // multiplier (enlarge array memory
	// dyn_array_mult times  )
	T *m_values;

public:

	class iterator;

public:

	ring()//constructor
	{
		m_pos = 0;
		m_realsize = dyn_array_step; // First, allocate step
		// for dyn_array_step items
		m_size = 0;
		m_values = (T *) malloc(m_realsize * sizeof(T));

		if (m_values == NULL)
			throw MEMFAIL;

		cout << " Constructor" << endl;
	}
	~ring() {

		//		if (m_values) {
		//			free( m_values); // Freeing memory
		//			m_values = NULL;
		//		}

		delete[] m_values;
	}

	ring(const ring &other) //: m_pos(other.m_pos), m_size(other.m_size), m_realsize(other.m_realsize), m_values(other.m_values) // copy constructor
	{
		m_values = (T *) malloc(sizeof(T) * other.m_realsize);
		if (m_values == NULL)
			throw MEMFAIL;

		memcpy(m_values, other.m_values, sizeof(T) * other.m_realsize);
		// memcpy call -- coping memory contents
		m_realsize = other.m_realsize;
		m_size = other.m_size;
		m_pos = other.m_pos;

		cout << "Copy Constructor" << endl;
	}

	ring(unsigned int m_size) :
		m_pos(0), m_size(m_size), m_realsize(dyn_array_step), m_values(NULL) {

		m_values = new T[m_size];
	}

	void print() {
		cout << "ring" << endl;
	}


	//containers
public:

	unsigned int size() const {//get the size of the array
		return m_size;
	}

	void clear() {// clear array

	}

	void swap(T& a, T& b) // clear x reallocating
	{
		T c(std::move(a));
		a = std::move(b);
		b = std::move(c);
	}

	T &get(unsigned int pos) {// get element in array
		return m_values[pos];
	}

	unsigned int getSize(); // get size of array (elements)
	void setSize(unsigned int newsize); // set size of array (elements)

	//sequences
public:

	//	 T & operator[](int index) const
	//	 T & operator[](int index) const; // & the Bad
	//	 T & front() {
	//	 return operator[](0);
	//	 }
	//	 const T & front() const {
	//	 return operator[](0);
	//	 }
	//	 T & back() {
	//	 return operator[](size() - 1);
	//	 }
	//	 const T & back() const {
	//	 return operator[](size() - 1);
	//	 }
	void add(const T & value) {

		//m_values[m_pos] = value;
		//m_pos++;

		m_values[m_pos++] = value;
		if (m_pos == m_size) {
			m_pos = 0;
		}

	}

	void pop() {

		if (m_size > 0) {
			delete &m_values[0];
		}
	}

	void erase(int pos) {
		if (m_size >= pos) {
			delete m_values[pos];
		}
	}



	void Delete(unsigned int pos); // delete array item

	//operators
public :
	const ring &operator=(const ring &other) // assignment operator
	{
	    if (this == &a) // in case somebody tries assign array to itself
			return *this;

		if (other.m_size == 0) // is other array is empty -- clear this array
			clear();

		setSize(other.m_size); // set size

	    memcpy(m_values, other.m_values, sizeof(T)*other.m_size);

	    cout << "Assignment running" << endl;

	    return *this;
	}


};

template<typename T>
class ring<T>::iterator {
public:
	void print() {
		cout << "Hello from Ring iterator... Type Id: " << typeid(T).name()
				<< endl;
	}

};

#endif /* RING_H_ */
