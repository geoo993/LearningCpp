/*
 * ring.h
 *
 *  Created on: 5 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef RING_H_
#define RING_H_

#include <iostream>
using namespace std;

template<typename T>
class ring {
private:

	int m_pos;
	int m_size;
	T *m_values;

public:

	class iterator;

public:

	ring();
	ring(int m_size) : m_pos(NULL), m_size(m_size), m_values(NULL){
		m_values = new T[m_size];
	}

	~ring(){
		delete [] m_values;
	}

	//containers
public:

	int size() const{
		return m_size;
	}

	void clear(){

	}

	void swap (T& a, T& b) // clear x reallocating
	{
	  T c(std::move(a)); a=std::move(b); b=std::move(c);
	}

//sequences
public:

//	 T & operator[](int index) const
//	 T & operator[](int index) const; // & the Bad
//	 T & front() {
//	 return operator[](0);
//	 }
//	 const T & front() const {
//	 return operator[](0);
//	 }
//	 T & back() {
//	 return operator[](size() - 1);
//	 }
//	 const T & back() const {
//	 return operator[](size() - 1);
//	 }
	 void add(const T & value){
		 m_values[m_pos] = value;
		 m_pos++;

		 if(m_pos == m_size){
			 m_pos = 0;
		 }


	 }
	 void pop();



};


template<typename T>
class ring<T>::iterator {
public:
	void print(){
		cout << "Hello from Ring iterator... Type Id: " << typeid(T).name() << endl;
	}

};


#endif /* RING_H_ */
