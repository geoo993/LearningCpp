/*
 * ring.h
 *
 *  Created on: 5 Nov 2016
 *      Author: GeorgeQuentin
 */

#ifndef RING_H_
#define RING_H_

#include <iostream>
#include <cstdlib>
using namespace std;


template<class el>
class AeDynArray
{
public:
    AeDynArray(); // constructor
    AeDynArray(const AeDynArray &a); // copy constructor
    ~AeDynArray(); // distructor
    AeDynArray& operator = (const AeDynArray &a); // assignment operator

    el& operator [] (unsigned int index); // get array item
    void Add(const el &item); // Add item to the end of array

    unsigned int GetSize(); // get size of array (elements)
    void SetSize(unsigned int newsize); // set size of array (elements)
    void Clear(); // clear array
    void Delete(unsigned int pos); // delete array item
	void* getptr(); // get void* pointer to array data

    enum exception { MEMFAIL }; // exception enum

};



template<typename T>
class ring {
private:

	unsigned int m_pos;//position in the array
	unsigned int m_size; //size of the array (elements)
	unsigned int m_realsize; // actual size of allocated memory
	const static int dyn_array_step = 128; // initial size of array memory (elements)
	const static int dyn_array_mult = 2; // multiplier (enlarge array memory
											 // dyn_array_mult times  )
	T *m_values;

public:

	class iterator;

public:

	ring()//constructor
	{
		cout << " Constructor" << endl;
	}
	ring(const ring &other): m_pos(NULL), m_size(m_size), m_values(NULL) // copy constructor
	{
		one = other.one;
		cout << "Copy Constructor" << one << endl;
	}

	void print(){
		cout << "ring" << endl;
	}


	ring(int m_size) : m_pos(NULL), m_size(m_size), m_values(NULL){
		m_values = new T[m_size];
	}

	~ring(){
		delete [] m_values;
	}

	//containers
public:

	int size() const{
		return m_size;
	}

	void clear(){

	}

	void swap (T& a, T& b) // clear x reallocating
	{
	  T c(std::move(a)); a=std::move(b); b=std::move(c);
	}

	T &get(int pos){
		return m_values[pos];
	}

//sequences
public:

//	 T & operator[](int index) const
//	 T & operator[](int index) const; // & the Bad
//	 T & front() {
//	 return operator[](0);
//	 }
//	 const T & front() const {
//	 return operator[](0);
//	 }
//	 T & back() {
//	 return operator[](size() - 1);
//	 }
//	 const T & back() const {
//	 return operator[](size() - 1);
//	 }
	 void add(const T & value){

		 //m_values[m_pos] = value;
		 //m_pos++;

		 m_values[m_pos++] = value;
		 if(m_pos == m_size){
			 m_pos = 0;
		 }

	 }

	 void pop(){

		 if (m_size>0){
			 delete &m_values[0];
		 }
	 }


	 void erase( int pos ){
		 if (m_size>=pos){
		 	delete m_values[pos];
		  }
	 }



};


template<typename T>
class ring<T>::iterator {
public:
	void print(){
		cout << "Hello from Ring iterator... Type Id: " << typeid(T).name() << endl;
	}

};


#endif /* RING_H_ */
