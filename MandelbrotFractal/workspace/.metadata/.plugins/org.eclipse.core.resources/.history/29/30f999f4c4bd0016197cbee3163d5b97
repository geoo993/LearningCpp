/*
 * FractalGenerator.cpp
 *
 *  Created on: 5 Dec 2016
 *      Author: GeorgeQuentin
 */

#include "FractalGenerator.h"

namespace fractalnamespace {

void FractalGenerator::addRange(double rangeEnd, const RGB &rgb){

	if (rangeEnd <= 1.0 || rangeEnd >= 0.0){
		m_ranges.push_back(rangeEnd * Mandelbrot::MAX_ITERATIONS);
		m_colors.push_back(rgb);

		if (m_bGotFirstRange) {
			m_rangeTotals.push_back(0);
		}
		m_bGotFirstRange = true;
	}else{
		assert(rangeEnd <= 1.0 || rangeEnd >= 0.0);
	}


}


void FractalGenerator::addZoomIn(const Zoom& zoom){
	m_zoomList.addUp(zoom);
}

void FractalGenerator::addZoomOut(const Zoom& zoom){
	m_zoomList.addDown(zoom);
}


void FractalGenerator::run(){

	if (output_type == "bitmap"){
		runBitmap("MandelbrotFractal.bmp");
	}else if (output_type == "window") {
		runWindow();
	}
}

void FractalGenerator::runBitmap(string name){

	setUp();
	writeBitmap(name);

}

void FractalGenerator::runWindow(){


	if (m_screen.init() == false) {
		cout << "ERROR INITIALIZING SCREEN WITH SDL." << endl;
	}
	cout << "SDL Init succeeded." << endl;


	setUp();

	bool running = true;
	while (running) {

		// Draw the screen
		m_screen.update();

		SDL_Event event;

		while (SDL_PollEvent(&event)) {

			if (event.type == SDL_QUIT) {
				running = false;
				break;
			}

			if (event.type == SDL_MOUSEBUTTONDOWN)
			{
				if (event.button.button == SDL_BUTTON(SDL_BUTTON_LEFT))
				{
					addZoomIn(Zoom(event.motion.x, event.motion.y, 0.3) );
					setUp();
				}
				if (event.button.button == SDL_BUTTON(SDL_BUTTON_RIGHT))
				{
					addZoomOut(Zoom(event.motion.x, event.motion.y, 0.3) );
					setUp();
				}

			}


		}


	}

	m_screen.close();

}

void FractalGenerator::setUp(){
	calculateIterations();
	calculateTotalIterations();
	calculateRangeTotals();
	drawFractal();
}


FractalGenerator::FractalGenerator(int width, int height, bool smooth_color, string output_type):
	m_width(width),
	m_height(height),
	m_histogram(new int[Mandelbrot::MAX_ITERATIONS]{0}),
	m_fractal(new int[m_width * m_height]{0}),
	m_bitmap(m_width, m_height),
	m_screen(m_width, m_height),
	m_zoomList(m_width, m_height),
	m_total(0),
	m_zooms({}),
	smooth_color(smooth_color),
	output_type(output_type)
	{


	addRange(0.0, RGB(0, 0 , 0 ) );
	addRange(0.3, RGB(255, 255 , 255 ) );
	addRange(0.5, RGB(255, 255 , 255));
	addRange(1.0, RGB( 255 , 255, 255));

	m_zoomList.addUp( Zoom(m_width/2, m_height/2, SCALE/m_width) );

}

void FractalGenerator::calculateIterations(){

	for (int y = 0; y < m_height; y++){

		for (int x = 0; x < m_width; x++){

			pair <double, double> coords = m_zoomList.doZoom(x, y);
			int iterations = Mandelbrot::getIterations(coords.first, coords.second);

			m_fractal[y * m_width + x] = iterations;

			if (iterations != Mandelbrot::MAX_ITERATIONS){
				m_histogram[iterations]++;
			}

		}
	}

}

void FractalGenerator::calculateTotalIterations(){

	for( int i = 0; i < Mandelbrot::MAX_ITERATIONS; i++) {
		m_total +=  m_histogram[i];
	}

}

void FractalGenerator::calculateRangeTotals(){

	int rangeIndex = 0;

	for(int i = 0; i < Mandelbrot::MAX_ITERATIONS; i++){
		int pixels =  m_histogram[i];

		if (i >= m_ranges[rangeIndex + 1]){
			rangeIndex++;
		}

		m_rangeTotals[rangeIndex] += pixels;

	}

}


void FractalGenerator::drawFractal(){

	std::tuple<int, int, int> rgb;

	for (int y = 0; y < m_height; y++){

		for (int x = 0; x < m_width; x++){

			int iterations = m_fractal[y * m_width + x]  ;

			if (smooth_color){
				rgb = get_rgb_smooth(iterations, 100);
			}else{
				rgb = get_rgb_piecewise_linear(iterations, 100);
			}
			uint8_t red = std::get<0>(rgb);
			uint8_t green = std::get<1>(rgb);
			uint8_t blue = std::get<2>(rgb);

			if (output_type == "bitmap"){
				m_bitmap.setPixel(x, y, red, green, blue);
			}else if (output_type == "window") {
				m_screen.setPixel(x, y, red, green, blue);
			}

		}
	}

}

std::tuple<int, int, int> FractalGenerator::get_rgb_piecewise_linear(int n, int iter_max) {
	int N = 256; // colors per element
	int N3 = N * N * N;
	// map n on the 0..1 interval (real numbers)
	double t = (double)n/(double)iter_max;
	// expand n on the 0 .. 256^3 interval (integers)
	n = (int)(t * (double) N3);

	int b = n/(N * N);
	int nn = n - b * N * N;
	int r = nn/N;
	int g = nn - r * N;
	return std::tuple<int, int, int>(r, g, b);
}

std::tuple<int, int, int> FractalGenerator::get_rgb_smooth(int n, int iter_max) {
	// map n on the 0..1 interval
	double t = (double)n/(double)iter_max;

	// Use smooth polynomials for r, g, b
	int r = (int)(9*(1-t)*t*t*t*255);
	int g = (int)(15*(1-t)*(1-t)*t*t*255);
	int b =  (int)(8.5*(1-t)*(1-t)*(1-t)*t*255);
	return std::tuple<int, int, int>(r, g, b);
}



void FractalGenerator::writeBitmap(string name){
	m_bitmap.write(name);
}

int FractalGenerator::getRange(int iterations) const{

	int range = 0;
	for(int i = 1; i < m_ranges.size(); i++){

		range = i;

		if(m_ranges[i] > iterations){
			break;
		}
	}

	range--;

	assert(range > -1);
	assert (range < m_ranges.size());

	return range;

}


void FractalGenerator::reset(){

	m_total = 0;
	m_bGotFirstRange = false;
	m_colors.clear();
	m_rangeTotals.clear();
	m_ranges.clear();
	m_histogram = nullptr;
	m_fractal = nullptr;

}


FractalGenerator::~FractalGenerator() {}

}
